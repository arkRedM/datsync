["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$console",["^ ","~$log",["^ "]],"~$Object",["^ "]],"~:use-macros",["^ ","~$go","~$cljs.core.async.macros","~$go-loop","^9"],"~:excludes",["~#set",[]],"~:name","~$dat.reactor","~:imports",null,"~:requires",["^ ","^5","~$taoensso.timbre","~$async","~$cljs.core.async","~$dat.spec.protocols","^D","^C","^C","~$datascript.core","^E","~$protocols","^D","~$com.stuartsierra.component","^G","~$dispatcher","~$dat.reactor.dispatcher","~$component","^G","^A","^A","^I","^I","~$d","^E"],"~:uses",null,"~:defs",["^ ","~$SimpleReactor",["^ ","~:num-fields",5,"~:protocols",["^<",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$com.stuartsierra.component/Lifecycle","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^=","~$dat.reactor/SimpleReactor","~:file","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","~:end-column",25,"~:type",true,"~:column",12,"~:internal-ctor",true,"~:line",281,"~:record",true,"~:end-line",281,"~:skip-protocol-flag",["^<",["^P","^Q","^R","^S","^T","^U","^V","^W","^X","^Z","^[","^11","^12"]]],"~$execute-effect!",["^ ","^=","~$dat.reactor/execute-effect!","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",117,"^17",1,"^1;",117,"^15",26,"~:meta",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",117,"^17",11,"^1;",117,"^15",26],"~:tag","~$cljs.core/MultiFn"],"~$dispatch!",["^ ","~:protocol-inline",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",27,"^17",7,"^1;",27,"^15",16,"~:arglists",["~#list",["~$quote",["^1E",[["~$reactor","~$message","~$level"],["^1G","^1H"]]]]],"~:top-fn",["^ ","~:variadic",false,"~:max-fixed-arity",3,"~:method-params",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]],"^1D",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]],"~:arglists-meta",["^1E",[null,null]]]],"^=","~$dat.reactor/dispatch!","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",16,"^1J",["^ ","^1K",false,"^1L",3,"^1M",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]],"^1D",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]],"^1N",["^1E",[null,null]]],"^1M",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]],"~:protocol-impl",null,"^1N",["^1E",[null,null]],"^17",1,"^19",27,"^1;",27,"^1L",3,"~:fn-var",true,"^1D",["^1E",[["^1G","^1H","^1I"],["^1G","^1H"]]]],"~$register-effect",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",148,"^17",7,"^1;",148,"^15",22,"^1D",["^1E",["^1F",["^1E",[["~$effect-id","~$effect-fn"],["^1S","~$middleware-fn","^1T"]]]]],"~:doc","Register an event handler. Optionally specify middleware as second arg. Can be a vector of such fns, as well.\n  Middleware is typical in order; First in the sequence ends up being responsible for creating the handler function\n  we spec this out). Also, calling this function registers an _event_ handler by the same effect-id; This should\n  eventually act as a default, but not override any event handler already set up with the same id, but for now avoid\n  collisions between event and effect ids.","^1J",["^ ","^1K",false,"^1L",3,"^1M",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1D",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1N",["^1E",[null,null]]]],"^=","~$dat.reactor/register-effect","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",22,"^1J",["^ ","^1K",false,"^1L",3,"^1M",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1D",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1N",["^1E",[null,null]]],"^1M",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",148,"^1;",148,"^1L",3,"^1Q",true,"^1D",["^1E",[["^1S","^1T"],["^1S","^1U","^1T"]]],"^1V","Register an event handler. Optionally specify middleware as second arg. Can be a vector of such fns, as well.\n  Middleware is typical in order; First in the sequence ends up being responsible for creating the handler function\n  we spec this out). Also, calling this function registers an _event_ handler by the same effect-id; This should\n  eventually act as a default, but not override any event handler already set up with the same id, but for now avoid\n  collisions between event and effect ids."],"~$concatv",["^ ","^=","~$dat.reactor/concatv","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",121,"^17",1,"^1;",121,"^15",13,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",121,"^17",6,"^1;",121,"^15",13],"^1@","~$any"],"~$preserve-meta",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",84,"^17",7,"^1;",84,"^15",20,"^1D",["^1E",["^1F",["^1E",[["~$handler-fn"]]]]]],"^=","~$dat.reactor/preserve-meta","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",20,"^1M",["^1E",[["^20"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",84,"^1;",84,"^1L",1,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^20"]]]]]],"~$with-effect",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",137,"^17",7,"^1;",137,"^15",18,"^1D",["^1E",["^1F",["^1E",[["~$effect","~$db"]]]]],"^1V","Registers effect on the database value. This is the mode of communication for effect message which need to get processed."],"^=","~$dat.reactor/with-effect","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",18,"^1M",["^1E",[["^23","^24"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",137,"^1;",137,"^1L",2,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^23","^24"]]]]],"^1V","Registers effect on the database value. This is the mode of communication for effect message which need to get processed."],"~$->SimpleReactor",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",281,"^17",12,"^1;",281,"^15",25,"^18",true,"~:factory","~:positional","^1D",["^1E",["^1F",["^1E",[["~$app","^H","^1G","~$conn","~$kill-chan"]]]]]],"^=","~$dat.reactor/->SimpleReactor","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",25,"^1M",["^1E",[["^29","^H","^1G","^2:","^2;"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^18",true,"^27","^28","^19",281,"^1;",281,"^1L",5,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^29","^H","^1G","^2:","^2;"]]]]]],"~$go-react!",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",237,"^17",7,"^1;",237,"^15",16,"^1D",["^1E",["^1F",["^1E",[["^1G","^29"]]]]],"^1V","Starts a go loop that processes events and effects using the handle-event! and\n  execute-effect! fns. Effects are executed in sequence after the transaction commits.\n  If a handler fails, the effects will not fire (will eventually support control over\n  this behavior)."],"^=","~$dat.reactor/go-react!","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",16,"^1M",["^1E",[["^1G","^29"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",237,"^1;",237,"^1L",2,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^1G","^29"]]]]],"^1V","Starts a go loop that processes events and effects using the handle-event! and\n  execute-effect! fns. Effects are executed in sequence after the transaction commits.\n  If a handler fails, the effects will not fire (will eventually support control over\n  this behavior)."],"~$handle-event!",["^ ","^=","~$dat.reactor/handle-event!","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",20,"^17",1,"^1;",20,"^15",24,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",20,"^17",11,"^1;",20,"^15",24],"^1@","^1A"],"~$new-simple-reactor",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",305,"^17",7,"^1;",305,"^15",25,"^1D",["^1E",["^1F",["^1E",[["~$options"],[]]]]],"^1V","If :app is specified, it is reacted on. If not, it is computed as a map of {:dispatcher :reactor :conn}","^1J",["^ ","^1K",false,"^1L",1,"^1M",["^1E",[["^2B"],[]]],"^1D",["^1E",[["^2B"],[]]],"^1N",["^1E",[null,null]]]],"^=","~$dat.reactor/new-simple-reactor","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",25,"^1J",["^ ","^1K",false,"^1L",1,"^1M",["^1E",[["^2B"],[]]],"^1D",["^1E",[["^2B"],[]]],"^1N",["^1E",[null,null]]],"^1M",["^1E",[["^2B"],[]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",305,"^1;",305,"^1L",1,"^1Q",true,"^1D",["^1E",[["^2B"],[]]],"^1V","If :app is specified, it is reacted on. If not, it is computed as a map of {:dispatcher :reactor :conn}"],"~$dispatch-error!",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",33,"^17",7,"^1;",33,"^15",22,"^1D",["^1E",["^1F",["^1E",[["^1G","^1H"]]]]]],"^=","~$dat.reactor/dispatch-error!","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",22,"^1M",["^1E",[["^1G","^1H"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",33,"^1;",33,"^1L",2,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^1G","^1H"]]]]]],"~$with-effects",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",124,"^17",7,"^1;",124,"^15",19,"^1D",["^1E",["^1F",["^1E",[["~$effects","^24"]]]]],"^1V","Registers effects on the database value. This is the mode of communication for effect message which need to get processed."],"^=","~$dat.reactor/with-effects","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",19,"^1M",["^1E",[["^2G","^24"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",124,"^1;",124,"^1L",2,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^2G","^24"]]]]],"^1V","Registers effects on the database value. This is the mode of communication for effect message which need to get processed."],"~$map->SimpleReactor",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",281,"^17",12,"^1;",281,"^15",25,"^18",true,"^27","~:map","^1D",["^1E",["^1F",["^1E",[["~$G__51822"]]]]]],"^=","~$dat.reactor/map->SimpleReactor","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",25,"^1M",["^1E",[["^2K"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^18",true,"^27","^2J","^19",281,"^1;",281,"^1L",1,"^1Q",true,"^1D",["^1E",["^1F",["^1E",[["^2K"]]]]]],"~$register-handler",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",92,"^17",7,"^1;",92,"^15",23,"^1D",["^1E",["^1F",["^1E",[["~$event-id","^20"],["^2N","^1U","^20"]]]]],"^1V","Register an event handler. Optionally specify middleware as second arg. Can be a vector of such fns, as well.\n  Middleware is typical in order; First in the sequence ends up being responsible for creating the handler function\n  that actually returns the final value. Except... We have some default handlers (see implementation, for now, till\n  we spec this out).","^1J",["^ ","^1K",false,"^1L",3,"^1M",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1D",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1N",["^1E",[null,null]]]],"^=","~$dat.reactor/register-handler","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",23,"^1J",["^ ","^1K",false,"^1L",3,"^1M",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1D",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1N",["^1E",[null,null]]],"^1M",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",92,"^1;",92,"^1L",3,"^1Q",true,"^1D",["^1E",[["^2N","^20"],["^2N","^1U","^20"]]],"^1V","Register an event handler. Optionally specify middleware as second arg. Can be a vector of such fns, as well.\n  Middleware is typical in order; First in the sequence ends up being responsible for creating the handler function\n  that actually returns the final value. Except... We have some default handlers (see implementation, for now, till\n  we spec this out)."],"~$resolve-to",["^ ","^1C",null,"^1?",["^ ","^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^19",41,"^17",7,"^1;",41,"^15",17,"^1D",["^1E",["^1F",["^1E",[["^29","^24","~$events",["^ ","~:as","^2B","~:keys",["~$datview.resolver/catch?"]]],["^29","^24","^2Q"]]]]],"^1V","Within a handle-event method implementation, you can call this function to resolve a single event to\n  some sequence of more atomic (presumably; thought you could get recursive...) events. This is a little bit\n  experimental at the moment, as there might be some gotchas with error handling flow. But for right now, you\n  have the option of specifying :datview.resolver/catch?, which lets you decide whether events should continue\n  getting processed if one of the events errors (if set to truthy, skips over the errored event). Note that\n  presently, errors do not bubble up. The last successful state of the db will be returned. Errors will be passed\n  through to the :datview/error.","^1J",["^ ","^1K",false,"^1L",4,"^1M",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1D",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1N",["^1E",[null,null]]]],"^=","~$dat.reactor/resolve-to","^1K",false,"^14","/home/bamarco/dev/datreactor/src/cljc/dat/reactor.cljc","^15",17,"^1J",["^ ","^1K",false,"^1L",4,"^1M",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1D",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1N",["^1E",[null,null]]],"^1M",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1P",null,"^1N",["^1E",[null,null]],"^17",1,"^19",41,"^1;",41,"^1L",4,"^1Q",true,"^1D",["^1E",[["^29","^24","^2Q",["^ ","^2R","^2B","^2S",["^2T"]]],["^29","^24","^2Q"]]],"^1V","Within a handle-event method implementation, you can call this function to resolve a single event to\n  some sequence of more atomic (presumably; thought you could get recursive...) events. This is a little bit\n  experimental at the moment, as there might be some gotchas with error handling flow. But for right now, you\n  have the option of specifying :datview.resolver/catch?, which lets you decide whether events should continue\n  getting processed if one of the events errors (if set to truthy, skips over the errored event). Note that\n  presently, errors do not bubble up. The last successful state of the db will be returned. Errors will be passed\n  through to the :datview/error."]],"~:require-macros",["^ ","~$async-macros","^9","^9","^9","^5","^A","^A","^A"],"~:cljs.analyzer/constants",["^ ","~:seen",["^<",["~:reactor","~:dat.reactor/local-tx","^2:","~:else","~:db-after","^1G","~:db","~:default","~:kill","~:dat.reactor/effects","~:dat.reactor/dispatch!","~:recur","~:dispatcher","~:debug","~:dat.reactor/resolve-tx-report","~:datview.resolver/error","~:kill-chan","^H","~:priority","~:app","~:info","~:error","~:datview.resolver/catch?","^2;","~:hierarchy","^29","~:auto","~:dat.reactor/execute-tx-report-handlers!","~:p","~:listeners","~:conn"]],"~:order",["^3B","^33","^38","^3A","^3@","~:p","^3C","^3;","^39","^35","^32","^3:","^31","^2[","^3D","^3E","^3F","^36","^37","^3?","^3=","^30","^3>","^2Z","^3<","^34","^29","^H","^1G","^2:","^2;"]],"^1V",null]